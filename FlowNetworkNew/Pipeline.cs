//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;

[Serializable]
public class Pipeline
{
    // ---------------------- Fields ----------------------
    private Component[] connection;
    private int safetyLimit;
    private int currentFlow;
    private List<Point> inbetweenPoints;
    private int[] connectedOutIn;

    // ------------------- Properties -------------------
    public int[] ConnectedOutIn { get { return connectedOutIn; } set { connectedOutIn = value; } }
    public int CurrentFlow { get { return currentFlow; } set { currentFlow = value; } }
    public int SafetyLimit { get { return safetyLimit; } set { safetyLimit = value; } }
    public Component[] Connection { get { return connection; } set { connection = value; } }
    public List<Point> InbetweenPoints { get { return inbetweenPoints; } set { inbetweenPoints = value; } }


    // ------------------- Constructors -------------------
    public Pipeline(Component inComp, Component  outComp,  List<Point> inbetweenPoints, int safetyLimit, int[] outIn )
	{
        connection = new Component[2] { inComp, outComp };
        this.inbetweenPoints = inbetweenPoints;
        connectedOutIn = new int[2] { outIn[0], outIn[1] };
        SafetyLimit = safetyLimit;
        CurrentFlow = 0;
    }

    // --------------------- Methods ----------------------
    public void recalculateFlow(int NewFlow)
	{
        CurrentFlow = NewFlow;
        connection[1].recalculateFlow(NewFlow);
	}

    public void draw(Graphics gr)
    {
        /*Select different colors for the pipeline:
            - Green if the current flow is less than the safety limit
            - Red if the current flow is greater thatn the safety limit
         */
        Color color;
        if (CurrentFlow <= SafetyLimit)
        {
            color = Color.Green;
        }
        else
        {
            color = Color.Red;
        }
        Point startPoint = new Point();
        Point endPoint = new Point();
        // Check if the starting point is a pump and set the coordinates
        if (connection[0] is PumpSink)
        {
            if (((PumpSink)connection[0]).IsSink == false)
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize / 2, connection[0].Position.Y + connection[0].PictureSize / 2);
            }
            else
            {
                throw new Exception("The output is occupied!");
            }
        }
        // Check if the starting point is a merger and set the coordinates
        else if (connection[0] is Merger)
        {
            if (this == ((Merger)connection[0]).PipelineList[2])
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize * 4 / 5, connection[0].Position.Y + connection[0].PictureSize / 2);
            }
            else
            {
                throw new Exception("The output is occupied!");
            }
        }
        // Check if the starting point is an adjustable splitter and set the coordinates
        else if (connection[0] is AdjustableSplitter)
            if (this == ((Splitter)connection[0]).PipelineList[1])
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize * 3 / 4, connection[0].Position.Y + connection[0].PictureSize / 4);
            }
            else if (this == ((Splitter)connection[0]).PipelineList[2])
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize * 3 / 4, connection[0].Position.Y + connection[0].PictureSize*3/4);
            }
            else
            {
                throw new Exception("Both outputs are occupied!");
            }
        else if (connection[0] is Splitter)
        {
            if (this == ((Splitter)connection[0]).PipelineList[1])
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize * 4 / 5, connection[0].Position.Y + connection[0].PictureSize / 4);
            }
            else if (this == ((Splitter)connection[0]).PipelineList[2])
            {
                startPoint = new Point(connection[0].Position.X + connection[0].PictureSize * 4 / 5, connection[0].Position.Y + connection[0].PictureSize*4/5);
            }
            else
            {
                throw new Exception("Both outputs are occupied!");
            }
        }

        // Check if the ending point is a sink and set the coordinates
        if (connection[1] is PumpSink)
        {
            if (((PumpSink)connection[1]).IsSink)
            {
                endPoint = new Point(connection[1].Position.X + connection[1].PictureSize / 2, connection[1].Position.Y + connection[1].PictureSize / 2);
            }
            else
            {
                throw new Exception("The input is occupied!");
            }
        }
        // Check if the ending point is a merger and set the coordinates
        else if (connection[1] is Merger)
        {
            if (this == connection[1].PipelineList[0])
            {
                endPoint = new Point(connection[1].Position.X, connection[1].Position.Y + connection[1].PictureSize / 4);
            }
            else if (this == connection[1].PipelineList[1])
            {
                endPoint = new Point(connection[1].Position.X, connection[1].Position.Y + connection[1].PictureSize * 3 / 4);
            }
            else
            {
                throw new Exception("Both inputs are occupied!");
            }
        }
        // Check if the ending point is an adjustable splitter and set the coordinates
        else if (connection[1] is AdjustableSplitter)
        {
            if (this == connection[1].PipelineList[0])
            {
                endPoint = new Point(connection[1].Position.X + connection[1].PictureSize / 4, connection[1].Position.Y + connection[1].PictureSize / 2);
            }
            else
            {
                throw new Exception("The input is occupied!");
            }
        }
        else if (connection[1] is Splitter)
        {
            if (this == connection[1].PipelineList[0])
            {
                endPoint = new Point(connection[1].Position.X, connection[1].Position.Y + connection[1].PictureSize * 5 / 6);
                
            }
            else
            {
                throw new Exception("The input is occupied!");
            }
        }

        // actual drawing
        Pen myPen = new Pen(color);
        myPen.Width = 5;
        for (int i = 0; i < inbetweenPoints.Count; i++)
        {
            if (i < inbetweenPoints.Count)
            {
                if (i == 0)
                {
                    gr.DrawLine(myPen, startPoint, inbetweenPoints[i]);
                }
                if (inbetweenPoints.Count!=1 && i+1 < inbetweenPoints.Count)
                gr.DrawLine(myPen, inbetweenPoints[i], inbetweenPoints[i + 1]);
                if (i == inbetweenPoints.Count-1)
                    gr.DrawLine(myPen, inbetweenPoints[i], endPoint);
            }
        }
    }


}

